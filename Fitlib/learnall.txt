Welcome to your deep dive into the C language, using your Libft project as our guide. This document will be your primary learning resource.

--------------------------------
### PART 0: THE ABSOLUTE BASICS
--------------------------------

Before we look at a single function, let's understand the world they live in. Imagine you're building with LEGOs. You can't build a castle without knowing what a brick is, how bricks connect, and that you have a limited number of them.

**1. What is a C Library (like Libft)?**

- **The Idea**: Imagine you write a function to count the length of a string. You use it in one project. Then you start a new project and need to count a string's length again. Do you write the same code all over again? No. That's inefficient and error-prone.
- **The Solution**: You create a "library" â€“ a collection of pre-compiled, reusable functions. Your `libft.a` file is exactly this: a toolbox of functions (`ft_strlen`, `ft_memcpy`, etc.) that you can use in any future C project simply by "linking" it.

**2. What is a Function?**

A function is a named block of code that performs a specific task. Think of it as a recipe.

- `int ft_isalpha(int c)`
    - **Return Type (`int`)**: The type of result the recipe produces (e.g., a number, a character, etc.). `void` means it produces no result.
    - **Name (`ft_isalpha`)**: The name of the recipe.
    - **Parameters (`int c`)**: The ingredients the recipe needs to work. `c` is the name of the ingredient inside the function, and `int` is its type.

**3. What is a Variable and a Data Type?**

A variable is a named storage location for data. A data type tells the computer what kind of data it is.

- `int i;`:  `i` is a variable that can hold an integer (e.g., `-5`, `0`, `42`).
- `char c;`: `c` is a variable that can hold a single character (e.g., `'a'`, `'!'`, `'7'`).
- `size_t len;`: `size_t` is a special unsigned integer type used for sizes and counts. It's guaranteed to be large enough to represent the size of the largest possible object on your system. It's the correct type to use for things like string length.

**4. What is Memory? The Stack and the Heap**

This is one of the most important concepts in C.

- **The Stack**: Think of it as a stack of plates. When a function is called, it gets a new plate on top for its local variables (`int i;`, `char c;`). When the function finishes, its plate is removed, and all its local variables disappear forever. It's fast and automatic.
- **The Heap**: Think of this as a large, open warehouse of memory that you can request space from. When you need data to exist *beyond* the lifetime of a single function, you must ask for it from the heap using `malloc()` (memory allocation). 
    - **`malloc(10)`**: This is you asking the system, "Please give me 10 bytes of memory from the warehouse." It returns a pointer to the beginning of that memory block.
    - **`free(ptr)`**: When you are finished with the memory you `malloc`'d, you MUST return it to the system using `free()`. If you don't, you create a **memory leak**. Your program holds onto memory it's no longer using, and if it does this enough, it can run out of memory and crash.

**5. What is a Pointer? (The Secret to C)**

A pointer is not a normal variable. A normal variable holds a value (like the number 42). **A pointer holds the *memory address* of another variable.**

- `int num = 42;`: `num` is a variable holding the value `42`. It lives at a specific memory address, let's say `0x100`.
- `int *ptr;`: `ptr` is a pointer variable, designed to hold the address of an integer.
- `ptr = &num;`: The `&` operator gets the address of `num`. So, `ptr` now holds the value `0x100`.
- `*ptr`: The `*` operator (dereference) says, "Go to the address stored in `ptr` and get the value there." So, `*ptr` is `42`.

Why is this useful? It allows functions to modify variables from *other* functions. It's also how we work with strings and memory allocated on the heap.

**6. What is a String in C?**

In C, a string is not a special type. It is simply an array of characters that ends with a special "null terminator" character, `\0`. This `\0` is how C knows where the string ends.

- `char *s = "hello";` is stored in memory as: `['h', 'e', 'l', 'l', 'o', '\0']`
- This is why many string functions involve pointers and moving through memory until `*ptr == '\0'`.

Now that we have these basic concepts, we can begin to analyze the functions in Part 1.

-------------------------------------------------
### PART 1: RE-IMPLEMENTING STANDARD C FUNCTIONS
-------------------------------------------------

These are functions that already exist in the standard C library. The goal here is to understand how they work from scratch.

#### CATEGORY 1: CHARACTER CLASSIFICATION & CONVERSION

**The Big Idea: The ASCII Table**

How does a computer know that 'a' is a letter and '7' is a digit? It doesn't. To a computer, every character is just a number. The mapping from characters to numbers is called the ASCII standard.

- 'A' is 65, 'B' is 66, ..., 'Z' is 90.
- 'a' is 97, 'b' is 98, ..., 'z' is 122.
- '0' is 48, '1' is 49, ..., '9' is 57.

All the `is...` functions work by simply checking if the input character's number falls within a specific range.

---

**1. `ft_isalpha(int c)`**

- **Purpose**: To check if a character is an alphabet letter (a-z or A-Z).
- **Parameter**: `int c` - The character to check, passed as an integer.
- **Return Value**: Returns a non-zero value (true) if it's a letter, and 0 (false) if not.
- **Your Code's Logic**: `if ((c <= 90 && c >= 65) || (c <= 122 && c >= 97))`
    - This is a direct translation of the ASCII table. It checks if `c` is in the range of uppercase letters (65-90) OR in the range of lowercase letters (97-122).

**2. `ft_isdigit(int c)`**

- **Purpose**: To check if a character is a digit (0-9).
- **Your Code's Logic**: `if (c <= 57 && c >= 48)`
    - It simply checks if the character's ASCII value is between 48 ('0') and 57 ('9').

**3. `ft_isalnum(int c)`**

- **Purpose**: To check if a character is "alphanumeric" (a letter OR a digit).
- **Your Code's Logic**: `if ((c <= 90 && c >= 65) || (c <= 122 && c >= 97) || (c <= 57 && c >= 48))`
    - Instead of writing new code, a more "genius" way to implement this would have been to use the functions you already wrote: `if (ft_isalpha(c) || ft_isdigit(c))`. This is a key principle of programming: **Don't Repeat Yourself (DRY)**. Re-using your own code makes it more readable and easier to maintain.

**4. `ft_isascii(int c)`**

- **Purpose**: To check if a character is part of the standard ASCII table.
- **Your Code's Logic**: `if (c >= 0 && c <= 127)`
    - The standard ASCII table has 128 characters, numbered 0 to 127. This function checks if the character is in that range.

**5. `ft_isprint(int c)`**

- **Purpose**: To check if a character is "printable". This includes letters, numbers, punctuation, and the space character.
- **Your Code's Logic**: `if (c <= 126 && c >= 32)`
    - In the ASCII table, the characters from 0 to 31 are non-printable control characters (like newline, tab, etc.). This function correctly checks for any character from space (32) up to tilde (126).

**6. `ft_toupper(int c)` & `ft_tolower(int c)`**

- **Purpose**: To convert a character to its uppercase or lowercase equivalent.
- **The Trick**: Look at the ASCII table again. The distance between any lowercase letter and its uppercase equivalent is exactly 32. ('a' is 97, 'A' is 65. 97 - 65 = 32).
- **`ft_toupper` Logic**: `if (c <= 122 && c >= 97) return (c - 32);`
    - It first checks if `c` is a lowercase letter. If it is, it returns the character's value minus 32, which is its uppercase version.
- **`ft_tolower` Logic**: `if (c <= 90 && c >= 65) return (c + 32);`
    - It checks if `c` is an uppercase letter. If it is, it returns the character's value plus 32.
- **Important**: If the character is not a letter, these functions correctly return it unchanged, which is the required behavior.

#### CATEGORY 2: STRING MANIPULATION

**The Big Idea: Pointers and the Null Terminator (`\0`)**

Strings are not a built-in type in C. They are `char *` (a pointer to a character). This means they are just the memory address of the *first* character. C knows where the string ends by looking for the first `\0` character. Almost every string function involves moving a pointer through memory, character by character, until this `\0` is found.

---

**1. `ft_strlen(const char *s)`**

- **Purpose**: To count the number of characters in a string, *not* including the `\0`.
- **Parameter**: `const char *s` - A pointer to the first character of the string.
- **Return Value**: `size_t` - The length of the string.
- **Your Code's Logic**: `while (*s++) i++;`
    - This is a very common and clever C idiom. Let's break it down:
    - `*s`: Dereferences the pointer `s`, getting the character value at the current address.
    - `*s++`: The `++` is a "post-increment", meaning it happens *after* the value is read. So, the `while` loop first checks the character `*s`. If it's not `\0` (which has a value of 0, so it's a false condition), the loop body executes. Then, `s` is incremented to point to the next character in memory. The loop continues until `*s` is `\0`.
    - For each character found, `i` is incremented. This is a fast and concise way to count the length.

**2. `ft_strchr(const char *s, int c)`**

- **Purpose**: To find the first occurrence of a specific character `c` in a string `s`.
- **Return Value**: A pointer to the first matching character in `s`, or `NULL` if the character is not found.
- **Your Code's Logic**: It loops through the string. If it finds the character, it returns the current pointer `s`. A crucial detail is what happens if `c` is `\0`. The loop condition `while (*s)` will stop when `*s` is `\0`, so the loop itself won't find it. The code correctly adds a check `if (*s == (unsigned char)c)` after the loop to handle this specific edge case.

**3. `ft_strrchr(const char *s, int c)`**

- **Purpose**: To find the *last* occurrence of a character `c` in a string `s`.
- **Return Value**: A pointer to the last matching character, or `NULL`.
- **Your Code's Logic**: This is trickier. Your code first finds the end of the string. Then, it iterates *backwards* from the end, checking each character. The first one it finds is, by definition, the last one in the string. This is a good, efficient approach.

**4. `ft_strncmp(const char *s1, const char *s2, size_t n)`**

- **Purpose**: To compare two strings, but for at most `n` characters.
- **Return Value**: An integer that is:
    - `< 0` if `s1` is less than `s2`.
    - `0` if `s1` is equal to `s2`.
    - `> 0` if `s1` is greater than `s2`.
- **Core Concept**: "Greater than" or "less than" for strings is based on the ASCII values of the characters. The comparison happens at the first character where the strings differ. For example, "apple" is less than "apply" because at the 4th character, 'l' (ASCII 108) is less than 'p' (ASCII 112).
- **Your Code's Logic**: It iterates through both strings, as long as the character count `i` is less than `n`. In each iteration, it checks if `s1[i]` and `s2[i]` are different. If they are, it immediately returns the difference of their ASCII values (`s1[i] - s2[i]`), which will be negative, positive, or zero as required. If the loop finishes (meaning the first `n` characters were identical), it returns 0.

**5. `ft_strdup(const char *src)`**

- **Purpose**: To duplicate a string.
- **Genius-Level Concept**: Why do we need this? If you do `char *copy = src;`, you are NOT making a copy. You are just creating a new pointer that points to the *same* memory. If you change `src`, `copy` will also change. `ft_strdup` allocates brand new memory on the **heap** using `malloc` and then copies the string content into that new memory.
- **Return Value**: A pointer to the newly allocated, copied string. This new pointer MUST be `free()`'d later to avoid memory leaks.
- **Your Code's Logic**:
    1. It first calculates the length of the source string `src`.
    2. It allocates new memory of `len + 1` bytes (`+1` for the `\0`!).
    3. It copies the characters from `src` to the new memory block (`dest`).
    4. It returns the pointer to the new block.

#### CATEGORY 3: MEMORY MANIPULATION

**The Big Idea: The `void *` (Generic) Pointer**

These functions are more fundamental than string functions. They work on raw blocks of memory, byte by byte. They don't care about `\0` terminators. Because they can operate on *any* kind of data (an integer array, a struct, a string, etc.), they use a special kind of pointer: `void *`. This is a generic pointer that can point to anything. Before you can work with the data it points to, you must "cast" it to a specific type, like `(char *)` or `(int *)`, to tell the compiler how many bytes to work with at a time.

---

**1. `ft_memset(void *s, int c, size_t n)`**

- **Purpose**: To fill a block of memory with a specific byte.
- **Parameters**:
    - `void *s`: A pointer to the start of the memory block.
    - `int c`: The byte value to fill with (it's an `int` for historical reasons, but it's treated as a `char`).
    - `size_t n`: The number of bytes to fill.
- **Your Code's Logic**: `while (n-- > 0) *ptr++ = c;`
    1. It casts the `void *s` to a `char *ptr`. This is key. It tells the compiler to treat this memory as a sequence of single bytes.
    2. It loops `n` times. In each loop:
    3. `*ptr++ = c;`: It writes the value `c` into the byte `ptr` is pointing to, and *then* increments `ptr` to point to the next byte.

**2. `ft_bzero(void *s, size_t n)`**

- **Purpose**: A specific version of `memset` that *only* fills memory with zero (`\0`).
- **Genius-Level Tip**: A good implementation of `ft_bzero` would simply call `ft_memset`. `ft_bzero(s, n);` is identical to `ft_memset(s, 0, n);`. Your `physicsguy` implementation does it manually, which is fine, but calling your own existing function is a better demonstration of the DRY principle.

**3. `ft_memcpy(void *dest, const void *src, size_t n)`**

- **Purpose**: To copy `n` bytes of memory from a source location `src` to a destination `dest`.
- **CRITICAL FLAW**: `memcpy` has undefined behavior if the source and destination memory blocks overlap. It's like trying to move a rug while standing on it. For overlapping memory, you need `memmove`.
- **Your Code's Logic**: It casts both `dest` and `src` to `char *` and then loops `n` times, copying one byte at a time from source to destination.

**4. `ft_memmove(void *dest, const void *src, size_t n)`**

- **Purpose**: The safe version of `memcpy`. It copies `n` bytes from `src` to `dest`, but correctly handles cases where the memory blocks overlap.
- **The Genius Part**: How does it handle overlap? It checks if the destination address is *after* the source address.
    - **If `dest > src` (overlap where dest is further down)**: To avoid overwriting `src` data that it hasn't copied yet, it must copy *backwards* from the end of the block.
    - **If `dest < src` (no dangerous overlap)**: It can just copy forwards, exactly like `memcpy`.
- **Your Code's Logic**: Your code correctly implements this. It checks `if (dest_ptr > src_ptr)` and if so, it moves the pointers to the end of the blocks (`dest_ptr + (n-1)`) and copies backwards. Otherwise, it just calls `ft_memcpy` to do a forward copy. This is an excellent, efficient implementation.

**5. `ft_calloc(size_t nmemb, size_t size)`**

- **Purpose**: To allocate memory for an array of `nmemb` elements, each of `size` bytes, and to initialize all the allocated memory to zero.
- **Difference from `malloc`**: `malloc(nmemb * size)` also allocates memory, but it doesn't initialize it to zero. The memory `malloc` gives you is full of random garbage data.
- **Security Aspect**: A critical job of `calloc` is to prevent integer overflow. Imagine `nmemb` and `size` are both very large numbers. `nmemb * size` could wrap around and become a small number, leading you to allocate a much smaller block of memory than you think. This is a major security vulnerability.
- **Your Code's Logic**:
    1. It calculates `total = nmemb * size`.
    2. It performs the security check: `if (total / nmemb != size)`. If the multiplication overflowed, this division will not equal the original `size`. This is a clever way to detect overflow.
    3. It calls `malloc(total)` to get the memory.
    4. It calls `ft_bzero(ptr, total)` to zero out the memory. This is a great use of your own functions!

**6. `ft_atoi(const char *str)`**

- **Purpose**: "ASCII to Integer". To convert a string of digits (e.g., "-42") into an actual `int` type.
- **Your Code's Logic**:
    1. **Skip Whitespace**: It first has a loop to skip any leading whitespace characters (`' '`, `'	'`, `'
'`, etc.).
    2. **Handle Sign**: It checks for a single `'-'` or `'+'` and sets a flag.
    3. **Convert Digits**: It loops while the characters are digits. In each loop, this is the core logic: `result = result * 10 + (str[i] - '0');`
        - `result * 10`: Shifts the existing digits one place to the left (e.g., 4 becomes 40).
        - `(str[i] - '0')`: This is a classic trick. The ASCII value of the character '4' minus the ASCII value of '0' results in the integer `4`. It converts the character digit to its integer equivalent.
        - It adds this new digit to the result.
    4. **Apply Sign**: Finally, if the sign flag was set for negative, it multiplies the result by -1.

-----------------------------------
### PART 2: ADDITIONAL FUNCTIONS
-----------------------------------

These functions do not have direct equivalents in the standard C library. They combine the concepts from Part 1 to create more powerful and complex tools. Nearly all of these functions allocate new memory on the heap, so you are responsible for `free()`'ing the memory they return!

**1. `ft_substr(const char *s, unsigned int start, size_t len)`**

- **Purpose**: To create a *new* string (a "substring") from a portion of an existing string `s`.
- **Parameters**:
    - `s`: The original string.
    - `start`: The index of the character to start the new string from.
    - `len`: The maximum length of the new string.
- **Return Value**: A pointer to the newly allocated substring on the heap.
- **Core Concept**: This is a perfect example of why we need heap allocation. The function creates a new string. If it stored this new string in a local variable (on the stack), the string would be destroyed the moment the function returns. By using `malloc`, the new string persists until you explicitly `free` it.
- **Your Code's Logic**:
    1. It performs several safety checks: if `s` is NULL, it returns NULL. If `start` is beyond the end of the string, it returns an empty, allocated string.
    2. It calculates the correct length to allocate, ensuring it doesn't try to read past the end of the original string.
    3. It calls `malloc` to create memory for the new substring.
    4. It uses `ft_memcpy` (great use of your own function!) to copy the characters from the correct starting position in `s` into the new memory.
    5. It null-terminates the new string and returns the pointer.

**2. `ft_strjoin(char const *s1, char const *s2)`**

- **Purpose**: To join two strings together into a single, new string.
- **Return Value**: A pointer to the newly allocated joined string.
- **Your Code's Logic**:
    1. It calculates the total length needed (`len(s1) + len(s2)`).
    2. It `malloc`s a new block of memory of `total_len + 1`.
    3. It uses `ft_strlcpy` to copy `s1` into the new memory block.
    4. It uses `ft_strlcat` to append `s2` onto the end of the new memory block.
    5. It returns the pointer to the new block. This is a very clean and efficient implementation that reuses your own functions perfectly.

**3. `ft_itoa(int n)`**

- **Purpose**: "Integer to ASCII". The opposite of `atoi`. It converts an integer (`-42`) into its string representation (`"-42"`).
- **Core Concept**: This is harder than `atoi`. To build the string, you need to know the digits in reverse order. The easiest way to get the last digit of a number is the modulo operator (`% 10`). For 123, `123 % 10` is 3. Then you divide by 10 (`123 / 10` is 12) and repeat. This gives you `3`, then `2`, then `1`. You need to store these characters backwards in your allocated string.
- **Your Code's Logic**:
    1. It handles edge cases like `n = 0` separately.
    2. It has a helper function `get_digits` to count how many characters are needed, including the sign.
    3. It `malloc`s the required memory.
    4. It sets the `\0` at the end of the allocated memory.
    5. It handles the negative sign by placing a `'-'` at the beginning.
    6. It enters a loop: in each step, it gets the last digit using `% 10`, converts it to a character (`+ '0'`), and places it at the end of the string. It then moves the string pointer backwards and divides the number by 10.

**4. The `ft_put..._fd` Functions**

- **Purpose**: These functions (`ft_putchar_fd`, `ft_putstr_fd`, etc.) are versions of your standard `put` functions, but they take an extra parameter: `int fd`.
- **Core Concept: File Descriptors (`fd`)**: In a Unix-like system, everything is a file. Your keyboard is a file, your screen is a file, and actual files on disk are files. The system identifies these using a simple integer called a file descriptor.
    - `0`: Standard Input (stdin) - usually your keyboard.
    - `1`: Standard Output (stdout) - usually your screen/terminal.
    - `2`: Standard Error (stderr) - also usually your screen, but it's a separate stream for error messages.
- **Why are they useful?**: They allow you to decide *where* to write your output. `ft_putstr_fd("hello", 1)` writes to the screen. `ft_putstr_fd("Error!", 2)` writes to the error stream. If you had a file open with `fd = 3`, `ft_putstr_fd("Log message", 3)` would write to that file. They all work by using the `write` system call, which is the low-level way to write bytes to any file descriptor.
